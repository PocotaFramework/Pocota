@page
@using Net.Leksi.Pocota
@using Net.Leksi.Pocota.FrameworkGenerator
@using Net.Leksi.Pocota.FrameworkGenerator.Pages.Server
@using Net.Leksi.Pocota.Server
@model DtoModel
@Html.Partial("Header", Model)

public class @Model.ClassName@{}(IServiceProvider services)@if(Model.BaseClasses.Any()){<text>: @Html.Raw(string.Join(", ", Model.BaseClasses))</text>}

{
    private const string s_notSet = "Not set!";
    private const string s_invalidTargetType = "The argument target must have type @Model.FullName!";
    private const string s_notBuildingDeserialization = "Not at Building or Deserialization stage!";
    private const string s_alreadyUsed = "The value is already used!";
    private const string s_notSerialization = "Not at Serialization stage!";
@if (Model.PocoKind is PocoKind.Entity)
{
    <text>    private const string s_primaryKey = "The Primary Key cannot be set indirectly!";
    private const string s_notAccessGiving = "Not at AccessGiving stage!";
</text>
}
#region PropertiesClasses
@foreach (PropertyModel pm in Model.Properties)
{
    <text>    public class @pm.Name@{}PropertyClass: @(Model.PocoKind is PocoKind.Entity ? nameof(IEntityProperty) : nameof(IProperty))
    {
        public string Name => "@pm.Name";
        public Type Type => typeof(@Html.Raw(pm.TypeName));
        public Type ItemType => typeof(@Html.Raw(pm.ItemTypeName));
        public bool IsCollection => @(pm.IsCollection ? "true" : "false");
        public bool IsNullable => @(pm.IsNullable ? "true" : "false");
        public bool IsReadOnly => @(pm.IsReadOnly ? "true" : "false");
        public @nameof(PocoKind) PocoKind  => @nameof(PocoKind).@pm.PocoKind;
        public object? GetValue(object target)
        {
            if(target is @Model.ClassName obj)
            {
    @if (pm.IsSelf) 
    {
        <text>                return obj;
</text>
    }
    else
    {
        <text>                return obj.@pm.Name;
</text>
    }
            }
            throw new ArgumentException(s_invalidTargetType);
        }
        public void SetValue(object target, object? value)
        {
    @if(pm.IsPrimaryKey)
    {
        <text>            throw new InvalidOperationException(s_primaryKey);
</text>
    }
    else
    {
        <text>            if(target is @Model.ClassName@{}@if(!pm.IsSelf){<text> obj</text>})
            {
        @if (!pm.IsSelf) 
        {
            <text>                obj.@pm.Name = (@Html.Raw(pm.TypeName)@(pm.IsNullable ? "?" : string.Empty))Convert.ChangeType(value, typeof(@Html.Raw(pm.TypeName)@(!pm.Type.IsClass && pm.IsNullable ? "?" : string.Empty)))@(!pm.IsNullable ? "!" : string.Empty);
</text>
        }
            }
            else
            {
                throw new ArgumentException(s_invalidTargetType);
            }
</text>
    }
        }
        public bool IsSet(object target)
        {
            if(target is @Model.ClassName@{}@if(!pm.IsSelf){<text> obj</text>})
            {
                return @if (pm.IsSelf) {<text>true</text>}else{<text>obj._@pm.Name@{}IsSet</text>};
            }
            throw new ArgumentException(s_invalidTargetType);
        }
    @if(Model.PocoKind is PocoKind.Entity)
    {
        <text>        public @nameof(AccessFlags) GetAccess(object target)
        {
            if(target is @Model.ClassName obj)
            {
                return obj._@pm.Name@{}Access;
            }
            throw new ArgumentException(s_invalidTargetType);
        }
        public void SetAccess(object target, @nameof(AccessFlags) access)
        {
            if(target is @Model.ClassName obj)
            {
                if(obj._processingInfo.ProcessingStage is ProcessingStage.AccessGiving)
                {
                    if(!obj._@pm.Name@{}Used)
                    {
                        obj._@pm.Name@{}Access = access;
                    }
                    else
                    {
                        throw new InvalidOperationException(s_alreadyUsed);
                    }
                }
                else
                {
                    throw new InvalidOperationException(s_notAccessGiving);
                }
            }
            else
            {
                throw new ArgumentException(s_invalidTargetType);
            }
        }

</text>
    }
    }
</text>
}
#endregion PropertiesClasses

#region Fields
@foreach (PropertyModel pm in Model.Properties)
{
    <text>    internal static readonly @pm.Name@{}PropertyClass s_@pm.Name@{}Property;
</text>
}
    private static readonly PropertyUse s_propertyUse;
    private readonly IProcessingInfo _processingInfo = services.GetRequiredService<IProcessingInfo>();
    private bool _SelfUsed = false;
@foreach (PropertyModel pm in Model.Properties)
{
    if (!pm.IsSelf)
    {
        <text>    private @Html.Raw(pm.TypeName)@(pm.IsNullable ? "?" : string.Empty) _@pm.Name@(!pm.IsNullable && pm.Type.IsClass ? " = null!" : string.Empty);
    private bool _@pm.Name@{}IsSet = false;    
    private bool _@pm.Name@{}Used = false;
</text>
    }
    
    @if(Model.PocoKind is PocoKind.Entity)
    {
        <text>    private @nameof(AccessFlags) _@pm.Name@{}Access = @nameof(AccessFlags).@nameof(AccessFlags.Read) | @nameof(AccessFlags).@nameof(AccessFlags.Update)@{}@if(pm.IsSelf){<text> | @nameof(AccessFlags).@nameof(AccessFlags.Delete)</text>};
</text>
    }
}
#endregion Fields

    static @Model.ClassName@{}()
    {
@foreach (PropertyModel pm in Model.Properties)
{
    <text>        s_@pm.Name@{}Property = new();
</text>
}
@{
    ViewDataDictionary vdd = new(ViewData);
    vdd["indentation"] = 8;
    <text>#region PropertyUse
        s_propertyUse = @Html.Partial("PropertyUse", Model.PropertyUse, vdd);
#endregion PropertyUse
</text>
}
    }

#region Properties
@if(Model.PocoKind is PocoKind.Entity)
{
    <text>    PropertyUse @nameof(IEntity)@{}.PropertyUse => s_propertyUse;
    IProcessingInfo  @nameof(IEntity)@{}.ProcessingInfo => _processingInfo;
    Type @nameof(IEntity)@{}.PrimaryKeyType => typeof(IPrimaryKey<@Model.BaseClasses.First()>);
</text>
}
@foreach(PropertyModel pm in Model.Properties.Where(p => !p.IsSelf))
{
    <text>    public override @Html.Raw(pm.TypeName)@(pm.IsNullable ? "?" : string.Empty) @pm.Name 
    { 
        get
        {
            if(!_@pm.Name@{}IsSet)
            {
                throw new InvalidOperationException(s_notSet);
            }
            if(_processingInfo.ProcessingStage is ProcessingStage.Serialization || _processingInfo.ProcessingStage is ProcessingStage.AccessGiving)
            {
                _@pm.Name@{}Used = true;
                _SelfUsed = true;
            }
            return _@pm.Name;
        }

    @if(!pm.IsPrimaryKey)
    {
        <text>        set
        {
            if(_processingInfo.ProcessingStage is ProcessingStage.Serialization || _processingInfo.ProcessingStage is ProcessingStage.AccessGiving)
            {
                throw new InvalidOperationException(s_notBuildingDeserialization);
            }
            if(_@pm.Name != value){
                if(_@pm.Name@{}Used)
                {
                    throw new InvalidOperationException(s_alreadyUsed);
                }
                _@pm.Name = value;
                _@pm.Name@{}IsSet = true;
            }

        }
</text>
    }
    }
</text>
}
#endregion Properties
@if(Model.PocoKind is PocoKind.Entity)
{
    bool seqDeclared = false;
    <text>    IEnumerable<object?> @nameof(IPrimaryKey)@{}.GetPrimaryKey()
    {
    @foreach (PropertyModel pm in Model.Properties.Where(v => v.IsPrimaryKey).OrderBy(v => v.Name))
    {
    if(pm.PocoKind is PocoKind.Entity)
    {
        <text>        @if(!seqDeclared){<text>IEnumerable<object?> </text>}seq = _@pm.Name is {} ? ((@nameof(IPrimaryKey))_@pm.Name).GetPrimaryKey() : @pm.TypeName@{}Dto.GetEmptyPrimaryKey();
        foreach (object? pk in seq)
        {
            yield return pk;
        }
</text>
        seqDeclared = true;
    }
    else
    {
        <text>        yield return _@pm.Name;
</text>
    }
    }
    }
    internal static IEnumerable<object?> GetEmptyPrimaryKey()
    {
        @foreach (PropertyUseModel pu in Model.PropertyUse.Children.Where(v => v.Flags.HasFlag(PropertyUseFlags.PrimaryKey)))
        {
            if (Model.Properties.Where(v => $"{Model.ClassName}.s_{v.Name}Property".Equals(pu.PropertyName)).First().PocoKind is PocoKind.None)
            {
                <text>        yield return null;
</text>
            }
            else
            {
                <text>        foreach(var obj in @Model.Properties.Where(v => $"{Model.ClassName}.s_{v.Name}Property".Equals(pu.PropertyName)).First().TypeName@{}Dto.GetEmptyPrimaryKey())
        {
            yield return null;
        }
</text>
            }
        }
    }
    @foreach (PropertyModel pm in Model.Properties.Where(v => v.IsPrimaryKey))
    {
        <text>    internal void Set@{}@pm.Name@{}(@Html.Raw(pm.TypeName)@(pm.IsNullable ? "?" : string.Empty) value)
    {
        _@pm.Name = value;
    }
</text>
    }
</text>
}
}