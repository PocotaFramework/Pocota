@page
@using Net.Leksi.Pocota.Common;
@using Net.Leksi.Pocota.Server;
@model ClassModel

@Html.Partial("Header", Model)

public class @Model.ClassName : @Html.Raw(string.Join(", ", Model.Interfaces))
{
@if(Model.PrimaryKey is { })
{
    <text>    #region PrimaryKey    
    public class PrimaryKeyClass: @Model.PrimaryKey.Name
    {
        private readonly @Model.ClassName _owner;
        public override object? this[int index]
        {
            get
            {
                switch (index)
                {
    @for (int i = 0; i < Model.PrimaryKey!.Parts.Count; ++i)
    {
        if(Model.PrimaryKey!.Parts[i].Property is {})
        {
            <text>                    case @i:
            @if(!Model.PrimaryKey!.Parts[i].IsProperty)
            {
                 <text>                       return ((@Model.PrimaryKey!.Parts[i].PrimaryKeyClassName)((@nameof(IEntity))_owner.@Model.PrimaryKey!.Parts[i].Property).@Model.PrimaryKey!.Parts[i].KeyReference;
</text>
            }
            else
            {
                 <text>                       return _owner.@Model.PrimaryKey!.Parts[i].PropertyField;
</text>
            }
</text>
        }
    }
                    default:
                        return base[index];
                }
            }
            set
            {
                switch (index)
                {
    @for (int i = 0; i < Model.PrimaryKey!.Parts.Count; ++i)
    {
        if(Model.PrimaryKey!.Parts[i].Property is {})
        {
            <text>                    case @i:
            @if(Model.PrimaryKey!.Parts[i].IsProperty)
            {
                <text>                        @Model.PrimaryKey!.Parts[i].Type@Model.PrimaryKey!.Parts[i].AsTypeAsk value@{}@i = value as @Model.PrimaryKey!.Parts[i].Type@Model.PrimaryKey!.Parts[i].AsTypeAsk;
                        if (value is null || value@{}@i is null)
                        {
                            throw new @nameof(InvalidCastException)@{}();
                        }
                        _owner.@Model.PrimaryKey!.Parts[i].Property = (@Model.PrimaryKey!.Parts[i].Type)value@{}@i!;
                        break;
</text>
            }
            else
            {
                <text>                        @Model.PrimaryKey!.Parts[i].Type@Model.PrimaryKey!.Parts[i].AsTypeAsk value@{}@i = value as @Model.PrimaryKey!.Parts[i].Type@Model.PrimaryKey!.Parts[i].AsTypeAsk;
                        if (value is null || value@{}@i is null)
                        {
                            throw new @nameof(InvalidCastException)@{}();
                        }
                        ((@Model.PrimaryKey!.Parts[i].PrimaryKeyClassName)((@nameof(IEntity))_owner.@Model.PrimaryKey!.Parts[i].Property).@Model.PrimaryKey!.Parts[i].KeyReference = (@Model.PrimaryKey!.Parts[i].Type)value@{}@i!;
                        break;
</text>
            }
</text>
        }
    }
                    default:
                        base[index] = value;
                        break;
                }
            }
        }
        public override object? this[string name]
        {
            get
            {
                switch (name)
                {
    @for (int i = 0; i < Model.PrimaryKey!.Parts.Count; ++i)
    {
        if(Model.PrimaryKey!.Parts[i].Property is {})
        {
            <text>                    case @Html.Raw($"\"{@Model.PrimaryKey!.Parts[i].Name}\""):
            @if(!Model.PrimaryKey!.Parts[i].IsProperty)
            {
                        <text>                        return ((@Model.PrimaryKey!.Parts[i].PrimaryKeyClassName)((@nameof(IEntity))_owner.@Model.PrimaryKey!.Parts[i].Property).@Model.PrimaryKey!.Parts[i].KeyReference;
</text>
            }
            else
            {
                        <text>                        return _owner.@Model.PrimaryKey!.Parts[i].PropertyField;
</text>
            }
</text>
        }
    }
                    default:
                        return base[name];
                }
            }
            set
            {
                switch(name)
                {
    @for (int i = 0; i < Model.PrimaryKey!.Parts.Count; ++i)
    {
        if(Model.PrimaryKey!.Parts[i].Property is {})
        {
            <text>                    case @Html.Raw($"\"{@Model.PrimaryKey!.Parts[i].Name}\""):
            @if(Model.PrimaryKey!.Parts[i].IsProperty)
            {
                <text>                        @Model.PrimaryKey!.Parts[i].Type@Model.PrimaryKey!.Parts[i].AsTypeAsk value@{}@i = value as @Model.PrimaryKey!.Parts[i].Type@Model.PrimaryKey!.Parts[i].AsTypeAsk;
                        if (value is null || value@{}@i is null)
                        {
                            throw new @nameof(InvalidCastException)@{}();
                        }   
                        _owner.@Model.PrimaryKey!.Parts[i].Property = (@Model.PrimaryKey!.Parts[i].Type)value@{}@i!;
                        break;
</text>
            }
            else
            {
                <text>                        @Model.PrimaryKey!.Parts[i].Type@Model.PrimaryKey!.Parts[i].AsTypeAsk value@{}@i = value as @Model.PrimaryKey!.Parts[i].Type@Model.PrimaryKey!.Parts[i].AsTypeAsk;
                        if (value is null || value@{}@i is null)
                        {
                            throw new @nameof(InvalidCastException)@{}();
                        }
                        ((@Model.PrimaryKey!.Parts[i].PrimaryKeyClassName)((@nameof(IEntity))_owner.@Model.PrimaryKey!.Parts[i].Property).@Model.PrimaryKey!.Parts[i].KeyReference = (@Model.PrimaryKey!.Parts[i].Type)value@{}@i!;
                        break;
</text>
            }
</text>
        }
    }
                    default:
                        base[name] = value;
                        break;
                }
            }
        }
    @foreach (PrimaryKeyPartModel pkpm in Model.PrimaryKey!.Parts.Where(p => p.KeyReference is {}))
    {
        <text>        public override @Html.Raw(pkpm.Type)? @pkpm.Name 
        {
            get
            {
        @if(!@pkpm.IsProperty)
        {
                    <text>
                        return ((@pkpm.PrimaryKeyClassName)((@nameof(IEntity))_owner.@pkpm.Property).@pkpm.KeyReference;
</text>
        }
        else
        {
            <text>                       return _owner.@pkpm.Property;
</text>
        }
            }
            set
            {
        @if(pkpm.IsProperty)
        {
            <text>                @pkpm.Type@pkpm.AsTypeAsk value1 = value as @pkpm.Type@pkpm.AsTypeAsk;
                if (value is null || value1 is null)
                {
                    throw new @nameof(InvalidCastException)@{}();
                }
                _owner.@pkpm.Property = (@pkpm.Type)value1!;
</text>
        }
        else
        {
            <text>                @pkpm.Type@pkpm.AsTypeAsk value1 = value as @pkpm.Type@pkpm.AsTypeAsk;
                if (value is null || value1 is null)
                {
                    throw new @nameof(InvalidCastException)@{}();
                }
                ((@pkpm.PrimaryKeyClassName)((@nameof(IEntity))_owner.@pkpm.Property).@pkpm.KeyReference = (@pkpm.Type)value1!;
</text>
        }
            }
        }
</text>
    }
        
        public override bool IsAssigned 
        {
            get
            {
                return @for (int i = 0; i < Model.PrimaryKey!.Parts.Count; ++i)
    {       
        if(Model.PrimaryKey!.Parts[i].Property is {})
        {
                <text>s_@{}@Model.PrimaryKey!.Parts[@i].PropertyName@{}Property.IsSet(_owner) 
                    && </text>
        }
    }base.IsAssigned;
            }
        }
        
        internal PrimaryKeyClass(@Model.ClassName owner)
        {
            _owner = owner;
        }
    }
    #endregion PrimaryKey  
</text>
}

@if (Model.PocoKind is PocoKind.Entity)
{
    <text>    event @nameof(AccessPropertyChangedEventHandler)? @nameof(IEntity)@{}.AccessPropertyChanged
    {
        add
        {
            _accessPropertyChanged += value;
        }
        remove
        {
            _accessPropertyChanged -= value;
        }
    }
</text>
}

    private const string s_alreadyDelivered = "The property {0}.{1} is already delivered!";
    private const string s_isNotSet = "The property {0}.{1} is not set!";
#region Fields
    private readonly @nameof(IServiceProvider) _serviceProvider;
@if (Model.PocoKind is PocoKind.Entity)
{
    <text>    private @nameof(PropertyAccessMode) _accessMode = PropertyAccessMode.ReadOnly;
    private bool _isAccessChecked = false;
    private bool _isAccessChecking = false;
    private event @nameof(AccessPropertyChangedEventHandler)? _accessPropertyChanged;
    private readonly @nameof(EntityHeart) _heart;
</text>
}
else if (Model.PocoKind is PocoKind.Envelope)
{
    <text>    private readonly @nameof(PocoHeart) _heart;
</text>
}
@foreach(PropertyModel pm in Model.Properties)
{
    <text>    private @Html.Raw(pm.Type)@pm.Nullable @pm.FieldName = @if(pm.IsClass || pm.PocoKind is not PocoKind.NotAPoco || pm.IsCollection || !string.IsNullOrEmpty(@pm.Nullable))
    {
        <text>null@{}@if(string.IsNullOrEmpty(@pm.Nullable)){<text>!</text>}</text>
    } 
    else 
    {
        <text>default</text>
    };
    @if (Model.PocoKind is PocoKind.Entity)
    {
        <text>    private PropertyAccessMode @pm.FieldName@{}AccessMode = PropertyAccessMode.Full;
</text>
    }
    private bool @pm.FieldName@{}IsSet = false;
    private bool @pm.FieldName@{}IsDelivered = false;
</text>
}
@if(Model.PrimaryKey is { })
{
    <text>    private readonly PrimaryKeyClass _primaryKey;
</text>

}
#endregion Fields
#region Properties
@if (Model.PocoKind is PocoKind.Entity)
{
    <text>    protected @nameof(EntityHeart) Heart => _heart;
</text>
}
else if (Model.PocoKind is PocoKind.Envelope)
{
    <text>    protected @nameof(PocoHeart) Heart => _heart;
</text>
}
@if (Model.PrimaryKey is { })
{
    <text>    @nameof(IPrimaryKey) @nameof(IEntity)@{}.PrimaryKey => _primaryKey;
</text>

}
@if (Model.PocoKind is PocoKind.Entity)
{
    <text>    @nameof(PropertyAccessMode) @nameof(IEntity)@{}.AccessMode => _accessMode;
</text>
}
   
@foreach(PropertyModel pm in Model.Properties)
{
    <text>    public @Html.Raw(pm.Type)@pm.Nullable @pm.Name 
    {
        get => Get@{}@pm.Name@{}();
    @if(!pm.IsReadonly)
    {
        <text>        set => Set@{}@pm.Name@{}(value);
</text>
    }
    }
</text>
}
#endregion Properties
    public @Model.ClassName (@nameof(IServiceProvider) serviceProvider)@if (Model.PocoKind is PocoKind.Extender)
{
    <text>: base(serviceProvider)</text>
}
    {
        _serviceProvider = serviceProvider;
    }
#region Methods
@if(Model.PocoKind is PocoKind.Entity)
{
    <text>    void @nameof(IEntity)@{}.CheckAccess()
    {
    @if(Model.AccessProperties.Any())
    {
        <text>        if(!_isAccessChecked)
        {
            try 
            {
                _isAccessChecking = true;
                if(@string.Join(" || ", Model.AccessProperties.Select(p => $"!{p.FieldName}IsSet")))
                {
                    throw new @nameof(InvalidOperationException)@{}("Not all access properties are set!");
                }
        @foreach (PropertyModel ap in Model.AccessProperties.Where(p => p.PocoKind is PocoKind.Entity || p.PocoKind is PocoKind.Extender))
        {
            @if(ap.IsCollection)
            {
                <text>                foreach(@Html.Raw(ap.ItemType) item in @ap.FieldName@{})
                {
                    ((@nameof(IEntity))item).CheckAccess();
                }
</text>
            }
            else
            {
                <text>                ((@nameof(IEntity))@ap.FieldName).CheckAccess();
</text>
            }
        }
                _serviceProvider.GetRequiredService@{}@Html.Raw($"<{nameof(IAccessManager<object>)}<{Model.Interface}>>")@{}().CheckAccess(this);
                _isAccessChecked = true;
            }
            finally
            {
                _isAccessChecking = false;
            }
        }
</text>
    }
    }
</text>
}
@foreach(PropertyModel pm in Model.Properties)
{
    <text>    private void Set@{}@pm.Name@{}(@Html.Raw(pm.Type)@pm.Nullable value)
    {
        if(@pm.FieldName@{}IsDelivered)
        {
            throw new @nameof(InvalidOperationException)@{}(string.Format(s_alreadyDelivered, typeof(@Model.ClassName), nameof(@pm.Name)));
        }
    @if(pm.IsAccess)
    {
        <text>        if(value != @pm.FieldName)
        {
        @if(!pm.IsCollection)
        {
            if(pm.PocoKind is PocoKind.Entity)
            {
                <text>            if(@pm.FieldName is {})
            {
                ((@nameof(IEntity))@pm.FieldName).AccessPropertyChanged -= @pm.Name@{}Changed;
            }
            if(value is {})
            {
                ((@nameof(IEntity))value).AccessPropertyChanged += @pm.Name@{}Changed;
            }
</text>
            }
            else
            {
                <text>            AccessPropertyChanged?.Invoke();
            _isAccessChecked = false;
</text>
            }
        }
        else
        {

        }
        }
</text>
    }
        @pm.FieldName = value;
        @pm.FieldName@{}IsSet = @if(string.IsNullOrEmpty(pm.Nullable) && (pm.IsClass || pm.PocoKind is not PocoKind.NotAPoco || pm.IsCollection))
        {
            <text>value is {}</text>
        } 
        else 
        {
            <text>true</text>
        };
    }
    @if(pm.IsAccess && !pm.IsCollection && pm.PocoKind is PocoKind.Entity)
    {
        <text>    private void @pm.Name@{}Changed@{}()
    {
        _isAccessChecked = false;
    }
</text>
    }
    private @Html.Raw(pm.Type)@pm.Nullable Get@{}@pm.Name@{}()
    {
        if(!@pm.FieldName@{}IsSet)
        {
            throw new @nameof(InvalidOperationException)@{}(string.Format(s_isNotSet, typeof(@Model.ClassName), nameof(@pm.Name)));
        }
        return @pm.FieldName;
    }
</text>
}
#endregion Methods

}